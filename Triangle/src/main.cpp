#include <window.hpp>

#include <filament/Engine.h>
#include <filament/Renderer.h>
#include <filament/Scene.h>
#include <filament/View.h>
#include <filament/Camera.h>
#include <filament/Viewport.h>
#include <filament/SwapChain.h>
#include <filament/VertexBuffer.h>
#include <filament/IndexBuffer.h>
#include <filament/RenderableManager.h>
#include <filament/Material.h>
#include <filament/MaterialInstance.h>

#include <utils/EntityManager.h>
#include <math/vec4.h>
#include <filament/MaterialEnums.h>

#include <cstdio>
#include <cstdlib>


using namespace filament;
using namespace utils;

// Material generated by matc
static constexpr uint8_t MATERIAL_PACKAGE[] = {
    #include "../material/unlit_color.inc"
};

int main()
{
    Engine* engine = Engine::create(Engine::Backend::METAL);
    if (!engine) {
        fprintf(stderr, "Failed to create Filament engine\n");
    }

    constexpr int width {1000};
    constexpr int height {800};
    constexpr char const* title {"The Triangle"};
    Window window(width, height, title);

    SwapChain* swapChain = engine->createSwapChain(window.getMetalLayerHandle());
    if (!swapChain) {
        fprintf(stderr, "Failed to create SwapChain\n");
        Engine::destroy(&engine);
        return -1;
    }

    Renderer* renderer = engine->createRenderer();
    if (!renderer) {
        fprintf(stderr, "Failed to create Renderer\n");
        Engine::destroy(&engine);
        return -1;
    }

    Scene* scene = engine->createScene();
    View* view = engine->createView();

    Entity cameraEntity = EntityManager::get().create();
    Camera* camera = engine->createCamera(cameraEntity);
    camera->setProjection(45.0, 800.0 / 600.0, 0.1, 10.0);
    camera->lookAt({0, 0, 3}, {0, 0, 0});
    view->setCamera(camera);
    view->setScene(scene);

    Viewport vp(0, 0, 800, 600);
    view->setViewport(vp);

    // Triangle geometry
    struct Vertex { float pos[3]; };
    Vertex vertices[] = {
        {{ 0.0f,  0.5f, 0.0f}},
        {{-0.5f, -0.5f, 0.0f}},
        {{ 0.5f, -0.5f, 0.0f}},
    };
    uint16_t indices[] = {0, 1, 2};

    VertexBuffer* vb = VertexBuffer::Builder()
        .vertexCount(3)
        .bufferCount(1)
        .attribute(VertexAttribute::POSITION, 0,
                   VertexBuffer::AttributeType::FLOAT3)
        .build(*engine);

    vb->setBufferAt(*engine, 0,
        VertexBuffer::BufferDescriptor(vertices, sizeof(vertices)));

    IndexBuffer* ib = IndexBuffer::Builder()
        .indexCount(3)
        .bufferType(IndexBuffer::IndexType::USHORT)
        .build(*engine);

    ib->setBuffer(*engine,
        IndexBuffer::BufferDescriptor(indices, sizeof(indices)));

    Material* material = Material::Builder()
        .package(MATERIAL_PACKAGE, sizeof(MATERIAL_PACKAGE))
        .build(*engine);

    if (!material) {
        fprintf(stderr, "Failed to create material\n");
        Engine::destroy(&engine);
        return -1;
    }

    MaterialInstance* mi = material->createInstance();
    mi->setParameter("color", RgbaType::LINEAR, math::float4{1.0f, 0.2f, 0.2f, 1.0f});

    Entity triangle = EntityManager::get().create();
    RenderableManager::Builder(1)
        .boundingBox({{-1,-1,-1}, {1,1,1}})
        .material(0, mi)
        .geometry(0, RenderableManager::PrimitiveType::TRIANGLES, vb, ib)
        .build(*engine, triangle);

    scene->addEntity(triangle);

    window.show();
    window.run([&]() -> bool {
        if (renderer->beginFrame(swapChain)) {
            renderer->render(view);
            renderer->endFrame();
        }
        return true;  // return false to quit
    });

    engine->destroy(vb);
    engine->destroy(ib);
    engine->destroy(material);
    Engine::destroy(&engine);

    return 0;
}
