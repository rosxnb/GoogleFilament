#include <window.hpp>

#include <filament/Engine.h>
#include <filament/Renderer.h>
#include <filament/Scene.h>
#include <filament/View.h>
#include <filament/Camera.h>
#include <filament/Viewport.h>
#include <filament/SwapChain.h>
#include <filament/VertexBuffer.h>
#include <filament/IndexBuffer.h>
#include <filament/RenderableManager.h>
#include <filament/Material.h>
#include <filament/MaterialInstance.h>

#include <utils/EntityManager.h>
#include <math/vec4.h>
#include <filament/MaterialEnums.h>

#include <cstdio>
#include <cstdlib>


using namespace filament;
using namespace utils;

// Material generated by matc
static constexpr uint8_t MATERIAL_PACKAGE[] = {
    #include "../material/unlit_color.inc"
};

int main()
{
    Engine* engine = Engine::create(Engine::Backend::METAL);
    if (!engine) {
        fprintf(stderr, "Failed to create Filament engine\n");
    }

    constexpr int width {1000};
    constexpr int height {800};
    constexpr char const* title {"Triangle Events"};
    Window window(width, height, title);

    SwapChain* swapChain = engine->createSwapChain(window.getMetalLayerHandle());
    if (!swapChain) {
        fprintf(stderr, "Failed to create SwapChain\n");
        Engine::destroy(&engine);
        return -1;
    }

    Renderer* renderer = engine->createRenderer();
    if (!renderer) {
        fprintf(stderr, "Failed to create Renderer\n");
        Engine::destroy(&engine);
        return -1;
    }

    Scene* scene = engine->createScene();
    View* view = engine->createView();

    Entity cameraEntity = EntityManager::get().create();
    Camera* camera = engine->createCamera(cameraEntity);
    camera->setProjection(45.0, (double)width / height, 0.1, 10.0);
    camera->lookAt({0, 0, 3}, {0, 0, 0});
    view->setCamera(camera);
    view->setScene(scene);
    view->setViewport(Viewport(0, 0, width, height));

    // Triangle geometry
    struct Vertex { float pos[3]; };
    Vertex vertices[] = {
        {{ 0.0f,  0.5f, 0.0f}},
        {{-0.5f, -0.5f, 0.0f}},
        {{ 0.5f, -0.5f, 0.0f}},
    };
    uint16_t indices[] = {0, 1, 2};

    VertexBuffer* vb = VertexBuffer::Builder()
        .vertexCount(3)
        .bufferCount(1)
        .attribute(VertexAttribute::POSITION, 0,
                   VertexBuffer::AttributeType::FLOAT3)
        .build(*engine);

    vb->setBufferAt(*engine, 0,
        VertexBuffer::BufferDescriptor(vertices, sizeof(vertices)));

    IndexBuffer* ib = IndexBuffer::Builder()
        .indexCount(3)
        .bufferType(IndexBuffer::IndexType::USHORT)
        .build(*engine);

    ib->setBuffer(*engine,
        IndexBuffer::BufferDescriptor(indices, sizeof(indices)));

    Material* material = Material::Builder()
        .package(MATERIAL_PACKAGE, sizeof(MATERIAL_PACKAGE))
        .build(*engine);

    if (!material) {
        fprintf(stderr, "Failed to create material\n");
        Engine::destroy(&engine);
        return -1;
    }

    MaterialInstance* mi = material->createInstance();
    mi->setParameter("color", RgbaType::LINEAR, math::float4{1.0f, 0.2f, 0.2f, 1.0f});

    Entity triangle = EntityManager::get().create();
    RenderableManager::Builder(1)
        .boundingBox({{-1,-1,-1}, {1,1,1}})
        .material(0, mi)
        .geometry(0, RenderableManager::PrimitiveType::TRIANGLES, vb, ib)
        .build(*engine, triangle);

    scene->addEntity(triangle);

    // State for interactive camera control
    float cameraDistance = 3.0f;
    float cameraAngleX = 0.0f;
    float cameraAngleY = 0.0f;
    bool isDragging = false;

    // Setup callbacks
    WindowCallbacks callbacks;

    callbacks.onKey = [&](const KeyEvent& e) {
        if (e.isPressed) {
            printf("Key pressed: %d (Shift:%d Ctrl:%d Alt:%d Cmd:%d)\n", 
                   e.keyCode, e.shift, e.ctrl, e.alt, e.cmd);
            
            // ESC to quit
            if (e.keyCode == KeyCode::Escape) {
                printf("Escape pressed - quitting\n");
                window.quit();
            }
            
            // WASD camera movement
            if (e.keyCode == KeyCode::W) {
                cameraDistance -= 0.5f;
                printf("Moving camera closer: %.2f\n", cameraDistance);
            }
            if (e.keyCode == KeyCode::S) {
                cameraDistance += 0.5f;
                printf("Moving camera farther: %.2f\n", cameraDistance);
            }
        }
    };

    callbacks.onMouseButton = [&](const MouseButtonEvent& e) {
        printf("Mouse button %d %s at (%.1f, %.1f)\n", 
               e.button, e.isPressed ? "pressed" : "released", e.x, e.y);
        
        if (e.button == 0) { // Left button
            isDragging = e.isPressed;
        }
    };

    callbacks.onMouseMove = [&](const MouseMoveEvent& e) {
        if (isDragging) {
            // Rotate camera based on mouse drag
            cameraAngleX += e.deltaX * 0.01f;
            cameraAngleY += e.deltaY * 0.01f;
            
            // Clamp vertical angle
            if (cameraAngleY > 1.5f) cameraAngleY = 1.5f;
            if (cameraAngleY < -1.5f) cameraAngleY = -1.5f;
        }
    };

    callbacks.onScroll = [&](const ScrollEvent& e) {
        printf("Scroll: (%.2f, %.2f)\n", e.deltaX, e.deltaY);
        
        // Zoom with scroll wheel
        cameraDistance -= e.deltaY * 0.1f;
        if (cameraDistance < 0.5f) cameraDistance = 0.5f;
        if (cameraDistance > 10.0f) cameraDistance = 10.0f;
    };

    callbacks.onResize = [&](const WindowResizeEvent& e) {
        printf("Window resized to: %dx%d\n", e.width, e.height);
        
        // Update viewport and camera aspect ratio
        view->setViewport(Viewport(0, 0, e.width, e.height));
        camera->setProjection(45.0, (double)e.width / e.height, 0.1, 10.0);
    };

    callbacks.onRender = [&]() -> bool {
        // Update camera position based on angles and distance
        float x = sin(cameraAngleX) * cos(cameraAngleY) * cameraDistance;
        float y = sin(cameraAngleY) * cameraDistance;
        float z = cos(cameraAngleX) * cos(cameraAngleY) * cameraDistance;
        
        camera->lookAt({x, y, z}, {0, 0, 0});
        
        // Render frame
        if (renderer->beginFrame(swapChain)) {
            renderer->render(view);
            renderer->endFrame();
        }
        
        return true; // Continue running
    };

    // Show window and start event loop
    window.show();
    window.run(callbacks);

    // Cleanup
    engine->destroy(vb);
    engine->destroy(ib);
    engine->destroy(material);
    engine->destroy(swapChain);
    engine->destroy(renderer);
    engine->destroy(scene);
    engine->destroy(view);
    engine->destroyCameraComponent(cameraEntity);
    EntityManager::get().destroy(cameraEntity);
    Engine::destroy(&engine);

    return 0;
}
